(defparameter *fronteraBusqueda* '())
(defparameter *memoria* '())

(defparameter *operadores*	'((:Persona-Zorro (1 1 0 0))
                              (:Persona-Oveja (1 0 1 0))
                              (:Persona-Lechuga (1 0 0 1))
                              (:Persona (1 0 0 0))))

(defparameter *id* 0)
(defparameter *ancestro* nil)
(defparameter *solucion* nil)

(defun crearNodo (estado operador)
	(incf *id*)
	(list (1- *id*) estado *ancestro* (first operador)))

(defun dondeEstaBarca (estado)
	(if (= 1 (fifth ( first estado))) 0 1))

(defun insertarAFronteraDeBusqueda (estado operador metodoBusqueda)
	(let ((nodo (crearNodo estado operador)))
		(cond ((eql metodo :depth-first)
			(push nodo *fronteraBusqueda*))
		((eql metodo :breath-first)
			(setq *fronteraBusqueda* (append *fronteraBusqueda* (list nodo))))
		(T Nil))))

(defun obtenerDeFronteraDeBusqueda ()
	(pop *fronteraBusqueda*))

(defun operadorValido? (operador estado)
	(let* ((orillaActual (dondeEstaBarca estado))
		(granjero (first (nth orillaActual estado)))
		(zorro (second (nth orillaActual estado)))
		(oveja (third (nth orillaActual estado)))
		(lechuga (fourth (nth orillaActual estado))))
	(or (= granjero (first (second op)))
		(= zorro (second (second operador)))
		(= oveja (third (second operador)))
		(= lechuga (fourth (second operador))))))

(defun estadoValido? (estado)
	(let ((zorroOrigen (second (first estado)))
		(ovejaOrigen (third (first estado))))
		(lechugaOrigen (fourth (first estado)))
		(zorroDestino (second (second estado)))
		(ovejaDestino (third (second estado)))
		(lechugaDestino (fourth (second estado)))
		(and (not (= ovejaOrigen lechugaOrigen))
			 (not (= ovejaOrigen zorroOrigen))
			 (not (= ovejaDestino zorroDestino))
			 (not (= ovejaDestino lechugaDestino)))))

(defun voltear (bit) 
	(boole BOOLE-XOR bit 1))

(defun aplicarOperador (operador estado)
	(let* ((orilla0 (first estado))
         (orilla1 (second estado))
         (barca0 (first (first estado)))
         (zorro0 (second (first estado)))
         (oveja0 (third (first estado)))
         (lechuga0 (fourth (first estado)))
         (barca1 (first (first estado)))
         (zorro1 (second (second estado)))
         (oveja1 (third (second estado)))
         (lechuga1 (fourth (second estado)))
         (orillaActual (dondeEstaBarca estado))
         (operador (first operador)))
    (case operador
      (:Persona (if (= orilla-barco 0)
                    (list (list 0 zorro0 oveja0 lechuga0 0) (list 1 zorro0 ov1 leg1 1))
                    (list (list 1 zorro0 oveja0 lechuga0 1) (list 0 zorro0 ov1 leg1 0))))
      (:Persona-Zorro (if (= orillaActual 0)
                          (list (list 0 0 oveja0 lechuga0 0) (list 1 1 oveja1 lechuga1 1 1))
                          (list (list 1 1 oveja0 lechuga0 1) (list 0 0 oveja1 lechuga1 0))))
      (:Persona-Oveja (if (= orilla-barco 0)
                          (list (list 0 zorro0 0 lechuga0 0) (list 1 zorro1 1 lechuga1 1))
                          (list (list 1 zorro0 1 lechuga0 1) (list 0 zorro1 0 lechuga1 0))))
      (:Persona-Lechuga (if (= orilla-barco 0)
                            (list (list 0 zorro0 oveja0 0 0) (list 1 zorro1 oveja1 1 1))
                            (list (list 1 zorro0 oveja0 1 1) (list 0 zorro1 oveja1 0 0))))
      (T "Error"))))

(defun expandir (estado)
  (let ((descendientes nil)
        (nuevoEstado nil))
    (dolist (op *operadores* descendientes)
      (setq nuevo-estado (apply-operator op estado))
      (when (and (valid-operator op estado)
                 (valid-state nuevo-estado))
        (setq descendientes (cons (list nuevo-estado op) descendientes))))))(doList ))


