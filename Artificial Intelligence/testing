(defparameter *fronteraBusqueda* '())
(defparameter *memoria* '())

(defparameter *operadores*	'((:Persona-Zorro (1 1 0 0))
                              (:Persona-Oveja (1 0 1 0))
                              (:Persona-Lechuga (1 0 0 1))
                              (:Persona (1 0 0 0))))

(defparameter *id* 0)
(defparameter *ancestro* nil)
(defparameter *solucion* nil)

(defun crearNodo (estado operador)
	(incf *id*)
	(list (1- *id*) estado *ancestro* (first operador)))

(defun dondeEstaBarca (estado)
	(if (= 1 (fifth ( first estado))) 0 1))

(defun insertarAFronteraDeBusqueda (estado operador metodoBusqueda)
	(let ((nodo (crearNodo estado operador)))
		(cond ((eql metodoBusqueda :depth-first)
			(push nodo *fronteraBusqueda*))
		((eql metodoBusqueda :breath-first)
			(setq *fronteraBusqueda* (append *fronteraBusqueda* (list nodo))))
		(T Nil))))

(defun obtenerDeFronteraDeBusqueda ()
	(pop *fronteraBusqueda*))

(defun operadorValido? (operador estado)
	(let* ((orillaActual (dondeEstaBarca estado))
		(granjero (first (nth orillaActual estado)))
		(zorro (second (nth orillaActual estado)))
		(oveja (third (nth orillaActual estado)))
		(lechuga (fourth (nth orillaActual estado))))
	(or (= granjero (first (second operador)))
		(= zorro (second (second operador)))
		(= oveja (third (second operador)))
		(= lechuga (fourth (second operador))))))

(defun estadoValido? (estado)
	(let ((zorroOrigen (second (first estado)))
        (ovejaOrigen (third (first estado)))
        (orilla1 (first estado))
        (orilla2 (second estado))
		(lechugaOrigen (fourth (first estado)))
		(zorroDestino (second (second estado)))
		(ovejaDestino (third (second estado)))
		(lechugaDestino (fourth (second estado))))
	  (and (not (equal orilla1 '(0 1 1 0 0))) (not (equal orilla2 '(0 1 1 0 0))) (not (equal orilla1 '(0 0 1 1 0))) (not (equal orilla2 '(0 0 1 1 0))))))

(defun voltear (bit) 
	(boole BOOLE-XOR bit 1))

(defun aplicarOperador (operador estado)
	(let* ((orilla0 (first estado))
         (orilla1 (second estado))
         (barca0 (first (first estado)))
         (zorro0 (second (first estado)))
         (oveja0 (third (first estado)))
         (lechuga0 (fourth (first estado)))
         (barca1 (first (first estado)))
         (zorro1 (second (second estado)))
         (oveja1 (third (second estado)))
         (lechuga1 (fourth (second estado)))
         (orillaActual (dondeEstaBarca estado))
         (operador (first operador)))
    (case operador
      (:Persona (if (= orillaActual 0)
                    (list (list 0 zorro0 oveja0 lechuga0 0) (list 1 zorro1 oveja1 lechuga1 1))
                    (list (list 1 zorro0 oveja0 lechuga0 1) (list 0 zorro1 oveja1 lechuga1 0))))
      (:Persona-Zorro (if (= orillaActual 0)
                          (list (list 0 0 oveja0 lechuga0 0) (list 1 1 oveja1 lechuga1 1 1))
                          (list (list 1 1 oveja0 lechuga0 1) (list 0 0 oveja1 lechuga1 0))))
      (:Persona-Oveja (if (= orillaActual 0)
                          (list (list 0 zorro0 0 lechuga0 0) (list 1 zorro1 1 lechuga1 1))
                          (list (list 1 zorro0 1 lechuga0 1) (list 0 zorro1 0 lechuga1 0))))
      (:Persona-Lechuga (if (= orillaActual 0)
                            (list (list 0 zorro0 oveja0 0 0) (list 1 zorro1 oveja1 1 1))
                            (list (list 1 zorro0 oveja0 1 1) (list 0 zorro1 oveja1 0 0))))
      (T "Error"))))

(defun expandir (estado)
  (let ((descendientes nil)
        (nuevoEstado nil))
    (dolist (op *operadores* descendientes)
      (setq nuevoEstado (aplicarOperador op estado))
      (when (and (operadorValido? op estado)
                 (estadoValido? nuevoEstado))
        (setq descendientes (cons (list nuevoEstado op) descendientes))))))

(defun recuerdasElEstado? (estado memoria)
  (cond ((null memoria) nil)
        ((equal estado (second (first memoria))) T)
        (T (recuerdasElEstado? estado (rest memoria)))))

(defun  filtraMemoria (listaDeEstadosYOperadores) 
  (cond ((null  listaDeEstadosYOperadores)  nil)
        ((recuerdasElEstado? (first (first  listaDeEstadosYOperadores)) *memoria* )
         (filtraMemoria (rest  listaDeEstadosYOperadores)))
        (T  (cons  (first listaDeEstadosYOperadores) (filtraMemoria (rest listaDeEstadosYOperadores))))))

(defun extraerSolucion (nodo)
  (labels ((localizarNodo (id lista)
             (cond ((null lista) Nil)
                   ((equal id (first (first lista))) (first lista))
                   (T (localizarNodo id (rest lista))))))
    (let ((actual (localizarNodo (first nodo) *memoria*)))
      (loop while (not (null actual)) do
           (push actual *solucion*)
           (setq actual (localizarNodo (third actual) *memoria*))))
    *solucion*))

(defun mostrarSolucion (listaNodos)
  (format  t  "Solucion con ~A  pasos~%" (1- (length  listaNodos)))
  (let ((nodo nil))
    (dotimes (i (length listaNodos))
      (setq nodo (nth i listaNodos))
      (if (= i 0)
          (format t "Inicio en: ~A~%" (second  nodo))
          (format t "\(~A\) aplicando ~A  se  llega  a  ~A~%"  i (fourth  nodo)  (second  nodo))))))

(defun reset-all ()
  (setq  *fronteraBusqueda*  nil)
  (setq  *memoria*  nil)
  (setq  *id*  0)
  (setq  *ancestro*  nil)
  (setq  *solucion*  nil))

(defun busquedaCiega (inicial final metodo)
  (reset-all)
  (let ((nodo nil)
        (estado nil)
        (sucesores '())
        (operador nil)
        (meta-encontrada nil))
    (insertarAFronteraDeBusqueda inicial nil metodo)
    (loop until (or meta-encontrada (null *fronteraBusqueda*)) do
         (setq nodo (obtenerDeFronteraDeBusqueda)
               estado (second nodo)
               operador (third nodo))
         (push nodo *memoria*)
         (cond ((equal final estado)
                (format  t  "Exito. Meta encontrada en ~A  intentos~%" (first  nodo))
                (mostrarSolucion (extraerSolucion nodo))
                (setq meta-encontrada T))
               (T (setq *ancestro* (first nodo))
                  (setq sucesores (expandir estado))
                  (setq sucesores (filtraMemoria sucesores))
                  (loop for element in sucesores do
                       (insertarAFronteraDeBusqueda (first element) (second element) metodo)))))))



(trace busquedaCiega)
(trace insertarAFronteraDeBusqueda)
(busquedaCiega '((1 1 1 1 1)(0 0 0 0 0)) '((0 0 0 0 0)(1 1 1 1 1)) :depth-first)
(busquedaCiega '((1 1 1 1 1)(0 0 0 0 0)) '((0 0 0 0 0)(1 1 1 1 1)) :breath-first)

